{-# LANGUAGE DataKinds         #-}
{-# LANGUAGE FlexibleContexts  #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE TypeOperators     #-}
{-# LANGUAGE DeriveGeneric, DeriveAnyClass #-}
module Actor.MasterActor where

import           Actor.Master
import           Control.Concurrent
import           Control.Concurrent.STM
import           Control.Distributed.Process
import           Control.Distributed.Process.Backend.SimpleLocalnet
import           Control.Distributed.Process.Node                   (initRemoteTable)
import           Control.Monad
import           Control.Monad.Trans
import           Data.Aeson                                         as A
import           Data.Aeson.Types
import qualified Data.ByteString.Lazy                               as B
import           Data.ByteString.Lazy.UTF8                          as U
import           Data.Int
import           Data.List
import           Data.String
import           Data.Functor
import           Data.Text
import           GHC.Generics
import           Server.Service
import           Step.ReadExcel
import           Struct.Architecture
import           Struct.Struct
import           System.Environment                                 (getArgs)
--

masterActor :: Backend -> Req -> [NodeId] -> Process ()
masterActor backend request slaves = do
  let q = parseCfg
  forever $
    master slaves q request

atomRead = atomically . readTVar

jsonFile :: FilePath
jsonFile = "config/config.json"

getCfg :: IO B.ByteString
getCfg = B.readFile jsonFile

getCfgProp :: Connections -> Object
getCfgProp = cfgproperty

parseCfg :: Config
parseCfg = do
  config q 
  where
    q = do
      c <- liftIO getCfg
      let j = A.decode c 
      case j of
        Nothing -> X :: Config
        Just cfg -> return cfg
